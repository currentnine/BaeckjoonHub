#include <iostream>
#include <set>
#include <algorithm>

using namespace std;

set<int> s;

int n, q;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> q;

    int a, a2;
    int cur = 0;   // '현재 위치'를 나타내는 인덱스 (회전 이동 지원)

    // 초기 상태 입력: i번째 값이 1이면 set에 추가
    for(int i = 0 ; i < n; i++){
        cin >> a;
        if(a == 1) s.insert(i);
    }

    while(q--){
        cin >> a;

        // ----------------------------------------------------------
        // 1번 명령: 인덱스(a2)의 값 토글(1→0, 0→1)
        // ----------------------------------------------------------
        if(a == 1){
            cin >> a2;
            a2 -= 1;                   // 문제 특성: 입력은 1-indexed → 0-index 변환
            auto x = s.find(a2);

            // 존재하면 → 켜져 있었음 → 끄기
            if(x != s.end()) s.erase(x);
            // 없으면 → 꺼져 있었음 → 켜기
            else s.insert(a2);
        }

        // ----------------------------------------------------------
        // 2번 명령: 오른쪽으로 a2만큼 회전
        // cur 위치가 오른쪽으로 a2칸 이동하는 것과 동일
        // ----------------------------------------------------------
        else if(a == 2){
            cin >> a2;
            cur += a2;
            cur %= n;      // 원형 구조이므로 n을 넘어가면 wrap-around
        }

        // ----------------------------------------------------------
        // 3번 명령: 현재 위치(cur) 기준으로
        // 가장 가까운 1 위치까지의 거리 출력
        //
        // - cur 위치가 1이면 0 출력
        // - 오른쪽 방향으로 가장 가까운 1까지의 거리
        //   (원형 구조 고려)
        // ----------------------------------------------------------
        else if(a == 3){
            // 집합이 비어 있으면 1이 없음 → -1 출력
            if (s.empty()){
                cout << "-1\n";
                continue;
            }

            // 현재 위치에 1이 존재하는 경우
            auto x = s.find(cur);
            if(x != s.end()){
                cout << "0\n";
                continue;
            }

            // 현재 위치보다 큰 첫 번째 원소(오른쪽에서 가장 가까운 1)
            x = s.upper_bound(cur);

            if(x != s.end()){
                // 같은 구간 내에 1이 존재하면 단순 거리 출력
                cout << *x - cur << "\n";
            }
            else{
                // upper_bound 없음 → 원의 끝을 넘어감
                // 원형 구조 고려: 맨 앞(s.begin())까지 거리 계산
                cout << n - cur + *s.begin() << "\n";
            }
        }
    }
}
